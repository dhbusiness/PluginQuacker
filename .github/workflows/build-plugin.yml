name: Build QuackerVST Plugin

on:
  # Manual trigger from Actions tab
  workflow_dispatch:

jobs:
  build-macos:
    name: Build macOS Plugin
    runs-on: macos-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          
      - name: Update submodules (pull juce)
        run: |
          git submodule update --init --recursive
          
      - name: Setup Environment
        run: |
          echo "Setting up environment variables"
          echo "JUCE_VERSION=8.0.6" >> $GITHUB_ENV
          echo "PLUGIN_NAME=TremoloViolaVST" >> $GITHUB_ENV
          # Store keychain path consistently
          echo "KC_NAME=$RUNNER_TEMP/app-signing.keychain-db" >> $GITHUB_ENV
      
      - name: Print directory
        run: |
          pwd
          ls
          
      - name: Install Apple certificates (both app and installer)
        env:
          APPLICATION_CERTIFICATE_DATA: ${{ secrets.MACOS_CERTIFICATE }}
          APPLICATION_CERTIFICATE_PASS: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          INSTALLER_CERTIFICATE_DATA: ${{ secrets.MACOS_INSTALLER_CERTIFICATE }}
          INSTALLER_CERTIFICATE_PASS: ${{ secrets.MACOS_INSTALLER_CERTIFICATE_PWD }}
        run: |
          # Create a temporary directory for certificates
          APP_CERTIFICATE_PATH=$RUNNER_TEMP/app_certificate.p12
          INSTALLER_CERTIFICATE_PATH=$RUNNER_TEMP/installer_certificate.p12
          
          # Delete keychain if it already exists
          security delete-keychain "$KC_NAME" 2>/dev/null || true
          
          # Import application certificate from secrets
          echo $APPLICATION_CERTIFICATE_DATA | base64 --decode > $APP_CERTIFICATE_PATH
          
          # Import installer certificate from secrets (only if it exists)
          if [ -n "$INSTALLER_CERTIFICATE_DATA" ]; then
            echo $INSTALLER_CERTIFICATE_DATA | base64 --decode > $INSTALLER_CERTIFICATE_PATH
          fi
          
          # Create temporary keychain
          security create-keychain -p "$APPLICATION_CERTIFICATE_PASS" "$KC_NAME"
          security set-keychain-settings -lut 21600 "$KC_NAME"
          security unlock-keychain -p "$APPLICATION_CERTIFICATE_PASS" "$KC_NAME"
          
          # Import application certificate to keychain
          security import $APP_CERTIFICATE_PATH -P "$APPLICATION_CERTIFICATE_PASS" -A -t cert -f pkcs12 -k "$KC_NAME"
          
          # Import installer certificate to keychain (only if it exists)
          if [ -n "$INSTALLER_CERTIFICATE_DATA" ] && [ -f "$INSTALLER_CERTIFICATE_PATH" ]; then
            echo "Importing installer certificate..."
            security import $INSTALLER_CERTIFICATE_PATH -P "$INSTALLER_CERTIFICATE_PASS" -A -t cert -f pkcs12 -k "$KC_NAME"
          else
            echo "No installer certificate provided - will use application certificate for installer signing"
          fi
          
          security list-keychain -d user -s "$KC_NAME"
          
          # Clean up certificate files
          rm -f $APP_CERTIFICATE_PATH $INSTALLER_CERTIFICATE_PATH
          
          # Verify identities are available with detailed debugging
          echo ""
          echo "=== Available Code Signing Identities ==="
          security find-identity -v -p codesigning "$KC_NAME"
          echo ""
          echo "=== ALL Identities (for debugging) ==="
          security find-identity -v "$KC_NAME"
          echo ""
          echo "=== Application Certificates ==="
          security find-identity -v -p codesigning "$KC_NAME" | grep "Developer ID Application" || echo "❌ No Application certificates found"
          echo ""
          echo "=== Installer Certificates ==="
          security find-identity -v -p codesigning "$KC_NAME" | grep "Developer ID Installer" || echo "⚠️ No Installer certificates found"
          echo ""
          echo "=== Checking for any 'Installer' certificates ==="
          security find-identity -v "$KC_NAME" | grep -i "installer" || echo "⚠️ No certificates with 'installer' in the name found"
          
      - name: Create entitlements file
        run: |
          cat > entitlements.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.cs.allow-jit</key>
              <true/>
              <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
              <true/>
              <key>com.apple.security.cs.allow-dyld-environment-variables</key>
              <true/>
              <key>com.apple.security.cs.disable-library-validation</key>
              <true/>
              <key>com.apple.security.device.audio-input</key>
              <true/>
          </dict>
          </plist>
          EOF
          
      - name: Download and Build JUCE
        run: |
          cd QuackerVST/JUCE/extras/Projucer/Builds/MacOSX
          xcodebuild -configuration Release
          
          # Create a symlink to the built Projucer in the repository root
          cd /Users/runner/work/PluginQuacker/PluginQuacker
          ln -s QuackerVST/JUCE/extras/Projucer/Builds/MacOSX/build/Release/Projucer.app/Contents/MacOS/Projucer projucer
      
      - name: Verify Projucer
        run: |
          ls -la ./projucer
          ./projucer --version || echo "Projucer version check failed"
          
      - name: Resave JUCER file
        run: |
          echo "Resaving project file"
          ./projucer --resave QuackerVST/QuackerVST.jucer
       
      - name: Verify Xcode project
        run: |
          echo "Checking if Xcode project exists"
          ls -la QuackerVST/Builds/MacOSX
          
          echo "Checking Xcode project structure"
          ls -la QuackerVST/Builds/MacOSX/*.xcodeproj || echo "No Xcode projects found"
          
          echo "Looking for specific Xcode projects:"
          find QuackerVST/Builds -name "*.xcodeproj" | sort
       
      - name: Build Plugin
        run: |
          echo "Building plugin with explicit signing configuration"
          cd QuackerVST/Builds/MacOSX
          
          # Get the actual certificate identity from the keychain
          IDENTITY=$(security find-identity -v -p codesigning "$KC_NAME" | grep "Developer ID Application" | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          echo "Using signing identity: $IDENTITY"
          
          # Build with explicit signing settings that override project defaults
          xcodebuild \
            -configuration Release \
            -verbose \
            CODE_SIGN_IDENTITY="$IDENTITY" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM="A9MQYZSRQK" \
            PROVISIONING_PROFILE_SPECIFIER="" \
            CODE_SIGNING_REQUIRED=YES \
            CODE_SIGNING_ALLOWED=YES
          
          echo "Build exit code: $?" 
         
      - name: Examine project structure
        run: |
          echo "Examining overall project structure for plugin files"
          find . -name "*.vst3" -o -name "*.component" -o -name "*.app"
          
          echo "All directories under build:"
          find QuackerVST/Builds -type d | sort
          
          echo "Files in build directory (if it exists):"
          find QuackerVST/Builds -type f -name "*.plist" | head -20
          
      - name: Sign the plugin bundles
        run: |
          # Find the actual identity to use from the keychain
          IDENTITY=$(security find-identity -v -p codesigning "$KC_NAME" | grep "Developer ID Application" | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          echo "Found signing identity: $IDENTITY"
          
          # Sign VST3 plugins
          find . -name "*.vst3" -type d -exec codesign --force --options runtime --entitlements entitlements.plist --sign "$IDENTITY" {} \;
          
          # Sign AU Components
          find . -name "*.component" -type d -exec codesign --force --options runtime --entitlements entitlements.plist --sign "$IDENTITY" {} \;
          
          # Sign Standalone apps
          find . -name "*.app" -type d -exec codesign --force --options runtime --entitlements entitlements.plist --sign "$IDENTITY" {} \;
          
          # Verify signatures
          echo "Verifying signatures..."
          find . -name "*.vst3" -type d -exec codesign -vvv --deep --strict {} \; || echo "VST3 verification failed"
          find . -name "*.component" -type d -exec codesign -vvv --deep --strict {} \; || echo "AU verification failed"
          find . -name "*.app" -type d -exec codesign -vvv --deep --strict {} \; || echo "App verification failed"

      - name: Notarize plugins
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "Starting notarization process..."
          
          # Create a temporary directory for notarization files
          mkdir -p notarization_temp
          
          # Function to notarize a single plugin bundle
          notarize_plugin() {
            local plugin_path="$1"
            local plugin_name=$(basename "$plugin_path")
            local plugin_type="$2"  # VST3, AU, or APP
            
            echo "Preparing $plugin_name for notarization..."
            
            # Create a ZIP file for notarization (Apple requires ZIP format)
            local zip_name="notarization_temp/${plugin_name}-${plugin_type}.zip"
            cd "$(dirname "$plugin_path")"
            zip -r "$GITHUB_WORKSPACE/$zip_name" "$(basename "$plugin_path")"
            cd "$GITHUB_WORKSPACE"
            
            echo "Submitting $plugin_name to Apple's notarization service..."
            
            # Submit to notarization service and capture the submission ID
            local submission_output=$(xcrun notarytool submit "$zip_name" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait \
              --timeout 10m \
              --output-format json)
            
            # Parse the submission ID from the output
            local submission_id=$(echo "$submission_output" | grep -o '"id":"[^"]*' | cut -d'"' -f4)
            
            if [ -n "$submission_id" ]; then
              echo "Notarization submitted with ID: $submission_id"
              
              # Check if notarization was successful
              if echo "$submission_output" | grep -q '"status":"Accepted"'; then
                echo "✅ Notarization successful for $plugin_name"
                
                # Staple the notarization ticket to the original plugin
                echo "Stapling notarization ticket to $plugin_name..."
                xcrun stapler staple "$plugin_path"
                
                # Verify the stapling worked
                echo "Verifying stapled notarization for $plugin_name..."
                xcrun stapler validate "$plugin_path" && echo "✅ Stapling verified" || echo "❌ Stapling verification failed"
                
              else
                echo "❌ Notarization failed for $plugin_name"
                # Get detailed error information
                xcrun notarytool log "$submission_id" \
                  --apple-id "$APPLE_ID" \
                  --password "$APPLE_APP_PASSWORD" \
                  --team-id "$APPLE_TEAM_ID"
                return 1
              fi
            else
              echo "❌ Failed to submit $plugin_name for notarization"
              return 1
            fi
          }
          
          # Notarize all VST3 plugins
          echo "Looking for VST3 plugins to notarize..."
          for vst_path in $(find . -name "*.vst3" -type d); do
            notarize_plugin "$vst_path" "VST3" || echo "VST3 notarization failed: $vst_path"
          done
          
          # Notarize all AU components  
          echo "Looking for AU plugins to notarize..."
          for au_path in $(find . -name "*.component" -type d); do
            notarize_plugin "$au_path" "AU" || echo "AU notarization failed: $au_path"
          done
          
          # Notarize all standalone apps
          echo "Looking for Standalone apps to notarize..."
          for app_path in $(find . -name "*.app" -type d); do
            notarize_plugin "$app_path" "APP" || echo "App notarization failed: $app_path"
          done
          
          # Clean up temporary files
          rm -rf notarization_temp
          
          echo "Notarization process complete!"
      
      - name: Create artifacts directory
        run: |
          echo "Creating artifacts directory"
          mkdir -p artifacts
      
      - name: Package Plugin (comprehensive verification and packaging)
        run: |
          echo "Starting comprehensive plugin packaging"
          
          # Create artifacts directory
          mkdir -p artifacts
          
          # Initialize counters
          SUCCESS_COUNT=0
          FAILED_COUNT=0
          
          # Function to verify and package a plugin
          verify_and_package() {
            PLUGIN_PATH="$1"
            PLUGIN_TYPE="$2"
            PLUGIN_NAME=$(basename "$PLUGIN_PATH")
            BASE_NAME=$(echo "$PLUGIN_NAME" | sed 's/\.[^.]*$//')
            
            echo "Processing $PLUGIN_NAME ($PLUGIN_TYPE)..."
            
            # Verify code signature
            if codesign -vvv --deep --strict "$PLUGIN_PATH" 2>/dev/null; then
              echo "Code signature valid for $PLUGIN_NAME"
            else
              echo "Code signature failed for $PLUGIN_NAME"
              return 1
            fi
            
            # Verify notarization
            if xcrun stapler validate "$PLUGIN_PATH" 2>/dev/null; then
              echo "Notarization valid for $PLUGIN_NAME"
            else
              echo "Notarization failed for $PLUGIN_NAME"
              return 1
            fi
            
            # Package the plugin
            ZIP_NAME="$BASE_NAME-$PLUGIN_TYPE-macOS.zip"
            cd "$(dirname "$PLUGIN_PATH")"
            zip -r "$GITHUB_WORKSPACE/artifacts/$ZIP_NAME" "$(basename "$PLUGIN_PATH")"
            cd "$GITHUB_WORKSPACE"
            
            if [ -f "artifacts/$ZIP_NAME" ]; then
              echo "Successfully packaged $ZIP_NAME"
              return 0
            else
              echo "Failed to create package for $PLUGIN_NAME"
              return 1
            fi
          }
          
          # Process VST3 plugins
          find . -name "*.vst3" -type d | while read VST_PATH; do
            if verify_and_package "$VST_PATH" "VST3"; then
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            else
              FAILED_COUNT=$((FAILED_COUNT + 1))
            fi
          done
          
          # Process AU components
          find . -name "*.component" -type d | while read AU_PATH; do
            if verify_and_package "$AU_PATH" "AU"; then
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            else
              FAILED_COUNT=$((FAILED_COUNT + 1))
            fi
          done
          
          # Process Standalone apps
          find . -name "*.app" -type d | while read APP_PATH; do
            if verify_and_package "$APP_PATH" "Standalone"; then
              SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            else
              FAILED_COUNT=$((FAILED_COUNT + 1))
            fi
          done
          
          # Create build report
          echo "Build completed on $(date)" > artifacts/build-report.txt
          echo "Plugins successfully packaged: check individual ZIP files" >> artifacts/build-report.txt
          ls -la artifacts/ >> artifacts/build-report.txt
          
          # If no files were found, create a diagnostic file
          if [ ! "$(ls -A artifacts/*.zip 2>/dev/null)" ]; then
            echo "No plugin files found during build process" > artifacts/build-log.txt
            echo "Directory contents:" >> artifacts/build-log.txt
            find . -name "*.vst3" -o -name "*.component" -o -name "*.app" >> artifacts/build-log.txt
          fi
          
          echo "Packaging process complete"

      - name: Create macOS Installer Package
        run: |
          echo "Creating professional macOS installer package..."
          
          # Create installer staging directories
          mkdir -p installer_staging/vst3_payload/Library/Audio/Plug-Ins/VST3
          mkdir -p installer_staging/au_payload/Library/Audio/Plug-Ins/Components
          mkdir -p installer_staging/scripts
          mkdir -p installer_staging/resources
          
          # Copy plugins to staging directories
          echo "Staging plugin files for installer..."
          
          # Stage VST3 plugins
          VST3_COUNT=0
          for vst_path in $(find . -name "*.vst3" -type d); do
            if [ -d "$vst_path" ]; then
              plugin_name=$(basename "$vst_path")
              echo "Staging VST3: $plugin_name"
              cp -R "$vst_path" "installer_staging/vst3_payload/Library/Audio/Plug-Ins/VST3/"
              VST3_COUNT=$((VST3_COUNT + 1))
            fi
          done
          
          # Stage AU plugins
          AU_COUNT=0
          for au_path in $(find . -name "*.component" -type d); do
            if [ -d "$au_path" ]; then
              plugin_name=$(basename "$au_path")
              echo "Staging AU: $plugin_name"
              cp -R "$au_path" "installer_staging/au_payload/Library/Audio/Plug-Ins/Components/"
              AU_COUNT=$((AU_COUNT + 1))
            fi
          done
          
          echo "Found $VST3_COUNT VST3 plugins and $AU_COUNT AU plugins"
          
          # Create installer scripts
          cat > installer_staging/scripts/preinstall << 'EOF'
          #!/bin/bash
          # Pre-installation script
          echo "Preparing to install TremoloViola plugin..."
          
          # Create plugin directories if they don't exist
          mkdir -p "/Library/Audio/Plug-Ins/VST3"
          mkdir -p "/Library/Audio/Plug-Ins/Components"
          
          # Set proper permissions
          chmod 755 "/Library/Audio/Plug-Ins/VST3"
          chmod 755 "/Library/Audio/Plug-Ins/Components"
          
          exit 0
          EOF
          
          cat > installer_staging/scripts/postinstall << 'EOF'
          #!/bin/bash
          # Post-installation script
          echo "TremoloViola plugin installation completed successfully!"
          
          # Set proper ownership and permissions for installed plugins
          if [ -d "/Library/Audio/Plug-Ins/VST3" ]; then
            find "/Library/Audio/Plug-Ins/VST3" -name "TremoloViola*" -type d -exec chmod -R 755 {} \;
            find "/Library/Audio/Plug-Ins/VST3" -name "TremoloViola*" -type d -exec chown -R root:admin {} \;
          fi
          
          if [ -d "/Library/Audio/Plug-Ins/Components" ]; then
            find "/Library/Audio/Plug-Ins/Components" -name "TremoloViola*" -type d -exec chmod -R 755 {} \;
            find "/Library/Audio/Plug-Ins/Components" -name "TremoloViola*" -type d -exec chown -R root:admin {} \;
          fi
          
          # Notify audio system of new plugins (this helps DAWs detect the plugins)
          killall -9 AudioComponentRegistrar 2>/dev/null || true
          
          echo "Plugin installation and registration complete."
          echo "You may need to restart your DAW to see the new plugins."
          
          exit 0
          EOF
          
          # Make scripts executable
          chmod +x installer_staging/scripts/preinstall
          chmod +x installer_staging/scripts/postinstall
          
          # Create welcome and readme files
          cat > installer_staging/resources/Welcome.txt << 'EOF'
          Welcome to TremoloViola Plugin Installer
          
          This installer will install the TremoloViola audio plugin on your Mac.
          
          The plugin will be installed to:
          • VST3: /Library/Audio/Plug-Ins/VST3/
          • Audio Units: /Library/Audio/Plug-Ins/Components/
          
          After installation, you can use the plugin in any compatible DAW software.
          
          Click Continue to proceed with the installation.
          EOF
          
          cat > installer_staging/resources/ReadMe.txt << 'EOF'
          TremoloViola Plugin Installation
          
          SYSTEM REQUIREMENTS:
          • macOS 10.15 (Catalina) or later
          • Compatible DAW software (Logic Pro, Pro Tools, Ableton Live, etc.)
          • VST3 or Audio Units host support
          
          INSTALLATION:
          This installer will place the plugin files in the standard macOS audio plugin directories. Administrator privileges are required for installation.
          
          USAGE:
          After installation, restart your DAW and look for "TremoloViola" in your plugin list.
          
          UNINSTALLATION:
          To remove the plugin, delete the following files:
          • /Library/Audio/Plug-Ins/VST3/TremoloViola.vst3
          • /Library/Audio/Plug-Ins/Components/TremoloViola.component
          
          For support, please visit: https://github.com/dhbusiness/PluginQuacker
          EOF
          
          # Bundle ID (this is fine - you don't need a real domain)
          BUNDLE_ID_BASE="com.deividshvostovs.tremoloviola"
          
          # Build component packages and collect their paths
          PACKAGE_REFS=""
          CHOICE_REFS=""
          
          if [ $VST3_COUNT -gt 0 ]; then
            echo "Building VST3 component package..."
            pkgbuild \
              --root installer_staging/vst3_payload \
              --identifier "$BUNDLE_ID_BASE.vst3" \
              --version 1.0.0 \
              --scripts installer_staging/scripts \
              --install-location / \
              installer_staging/TremoloViola-VST3.pkg
            
            if [ -f "installer_staging/TremoloViola-VST3.pkg" ]; then
              echo "✅ VST3 component package created successfully"
              PACKAGE_REFS="$PACKAGE_REFS
                  <pkg-ref id=\"$BUNDLE_ID_BASE.vst3\" version=\"1.0.0\" auth=\"root\">TremoloViola-VST3.pkg</pkg-ref>"
              CHOICE_REFS="$CHOICE_REFS
                      <line choice=\"vst3\"/>"
            fi
          fi
          
          if [ $AU_COUNT -gt 0 ]; then
            echo "Building AU component package..."
            pkgbuild \
              --root installer_staging/au_payload \
              --identifier "$BUNDLE_ID_BASE.au" \
              --version 1.0.0 \
              --scripts installer_staging/scripts \
              --install-location / \
              installer_staging/TremoloViola-AU.pkg
            
            if [ -f "installer_staging/TremoloViola-AU.pkg" ]; then
              echo "✅ AU component package created successfully"
              PACKAGE_REFS="$PACKAGE_REFS
                  <pkg-ref id=\"$BUNDLE_ID_BASE.au\" version=\"1.0.0\" auth=\"root\">TremoloViola-AU.pkg</pkg-ref>"
              CHOICE_REFS="$CHOICE_REFS
                      <line choice=\"au\"/>"
            fi
          fi
          
          # Only proceed if we have at least one package
          if [ -n "$PACKAGE_REFS" ]; then
            # Create Distribution.xml with actual package references
            cat > installer_staging/Distribution.xml << EOF
          <?xml version="1.0" encoding="utf-8"?>
          <installer-gui-script minSpecVersion="2">
              <title>TremoloViola Plugin</title>
              <organization>$BUNDLE_ID_BASE</organization>
              <domains enable_localSystem="true"/>
              <options customize="never" require-scripts="false" rootVolumeOnly="true" />
              
              <!-- Welcome and ReadMe -->
              <welcome file="Welcome.txt" mime-type="text/plain" />
              <readme file="ReadMe.txt" mime-type="text/plain" />
              
              <!-- Installation check -->
              <installation-check script="pm_install_check();"/>
              <script>
          <![CDATA[
              function pm_install_check() {
                  if(!(system.version.ProductVersion >= '10.15')) {
                      my.result.title = 'Unable to install';
                      my.result.message = 'This plugin requires macOS 10.15 (Catalina) or later.';
                      my.result.type = 'Fatal';
                      return false;
                  }
                  return true;
              }
          ]]>
              </script>
              
              <!-- Define installation choices -->
              <choices-outline>
                  <line choice="default">$CHOICE_REFS
                  </line>
              </choices-outline>
              
              <choice id="default"/>
          EOF
          
            # Add choice definitions based on what packages we have
            if [ $VST3_COUNT -gt 0 ]; then
              cat >> installer_staging/Distribution.xml << EOF
              <choice id="vst3" visible="false">
                  <pkg-ref id="$BUNDLE_ID_BASE.vst3"/>
              </choice>
          EOF
            fi
            
            if [ $AU_COUNT -gt 0 ]; then
              cat >> installer_staging/Distribution.xml << EOF
              <choice id="au" visible="false">
                  <pkg-ref id="$BUNDLE_ID_BASE.au"/>
              </choice>
          EOF
            fi
            
            # Add package references
            cat >> installer_staging/Distribution.xml << EOF
              
              <!-- Package references -->$PACKAGE_REFS
              
          </installer-gui-script>
          EOF
            
            echo "Creating final installer package..."
            
            # Copy resources to staging
            cp installer_staging/resources/* installer_staging/ 2>/dev/null || true
            
            productbuild \
              --distribution installer_staging/Distribution.xml \
              --package-path installer_staging \
              --resources installer_staging/resources \
              TremoloViola-Installer.pkg
            
            if [ -f "TremoloViola-Installer.pkg" ]; then
              echo "✅ Final installer package created: TremoloViola-Installer.pkg"
              
              # Get package info
              echo "Package information:"
              ls -lh TremoloViola-Installer.pkg
              
            else
              echo "❌ Failed to create final installer package"
              exit 1
            fi
          else
            echo "❌ No component packages were created successfully"
            exit 1
          fi

      - name: Sign and Notarize Installer
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "Signing and notarizing installer package..."
          
          # Re-verify what certificates are available in our keychain
          echo ""
          echo "=== Pre-signing Certificate Check ==="
          security find-identity -v -p codesigning "$KC_NAME"
          echo ""
          echo "=== Application Certificates ==="
          security find-identity -v -p codesigning "$KC_NAME" | grep "Developer ID Application" || echo "❌ No Application certificates found"
          echo ""
          echo "=== All Certificates (including installer) ==="
          security find-identity -v "$KC_NAME"
          echo ""
          echo "=== Installer Certificates ==="
          security find-identity -v "$KC_NAME" | grep "Developer ID Installer" || echo "⚠️ No Installer certificates found"
          
          # Try to find Developer ID Installer certificate first (search without -p codesigning)
          INSTALLER_IDENTITY=$(security find-identity -v "$KC_NAME" | grep "Developer ID Installer" | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          
          # If no Installer certificate found, fall back to Application certificate
          if [ -z "$INSTALLER_IDENTITY" ]; then
            echo "⚠️ No Developer ID Installer certificate found, trying Developer ID Application certificate..."
            INSTALLER_IDENTITY=$(security find-identity -v -p codesigning "$KC_NAME" | grep "Developer ID Application" | head -1 | sed -E 's/.*"([^"]+)".*/\1/')
          fi
          
          if [ -n "$INSTALLER_IDENTITY" ]; then
            echo "✅ Found signing certificate: $INSTALLER_IDENTITY"
            
            # Sign the installer package
            echo "Signing installer package..."
            productsign --sign "$INSTALLER_IDENTITY" TremoloViola-Installer.pkg TremoloViola-Installer-Signed.pkg
            
            if [ -f "TremoloViola-Installer-Signed.pkg" ]; then
              echo "✅ Installer signed successfully"
              mv TremoloViola-Installer-Signed.pkg TremoloViola-Installer.pkg
              
              # Verify the signature
              echo "Verifying installer signature..."
              if spctl -a -v --type install TremoloViola-Installer.pkg; then
                echo "✅ Installer signature verified"
              else
                echo "⚠️ Installer signature verification failed, but continuing"
              fi
              
              # Notarize the installer
              echo "Submitting installer for notarization..."
              
              submission_output=$(xcrun notarytool submit TremoloViola-Installer.pkg \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_APP_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" \
                --wait \
                --timeout 15m \
                --output-format json 2>&1)
              
              echo "Notarization submission output:"
              echo "$submission_output"
              
              # Check if notarization was successful
              if echo "$submission_output" | grep -q '"status":"Accepted"'; then
                echo "✅ Installer notarization successful"
                
                # Staple the notarization ticket
                echo "Stapling notarization ticket..."
                if xcrun stapler staple TremoloViola-Installer.pkg; then
                  echo "✅ Notarization ticket stapled to installer"
                  
                  # Final verification
                  if xcrun stapler validate TremoloViola-Installer.pkg; then
                    echo "✅ Stapled installer validated successfully"
                  else
                    echo "⚠️ Stapled installer validation failed, but continuing"
                  fi
                else
                  echo "⚠️ Failed to staple notarization ticket, but continuing"
                fi
                
              else
                echo "❌ Installer notarization failed or timed out"
                echo "Full notarization output:"
                echo "$submission_output"
                
                # Check if it's still processing
                if echo "$submission_output" | grep -q '"status":"In Progress"'; then
                  echo "⚠️ Notarization still in progress - continuing with signed but unnotarized installer"
                else
                  echo "⚠️ Notarization failed - continuing with signed but unnotarized installer"
                fi
              fi
              
            else
              echo "❌ Failed to sign installer package"
              echo "⚠️ Continuing with unsigned installer"
            fi
            
          else
            echo "❌ No suitable signing certificate found"
            echo "Available signing identities:"
            security find-identity -v -p codesigning "$KC_NAME"
            echo "⚠️ Continuing with unsigned installer"
          fi
          
          # Verify the final installer exists
          if [ -f "TremoloViola-Installer.pkg" ]; then
            echo "✅ Final installer package ready: TremoloViola-Installer.pkg"
            ls -lh TremoloViola-Installer.pkg
            
            # Check if it's signed
            if pkgutil --check-signature TremoloViola-Installer.pkg > /dev/null 2>&1; then
              echo "✅ Installer is signed"
            else
              echo "⚠️ Installer is unsigned"
            fi
          else
            echo "❌ No installer package found"
            exit 1
          fi

      - name: Update artifacts with installer
        run: |
          echo "Adding installer to artifacts..."
          
          # Move installer to artifacts directory
          if [ -f "TremoloViola-Installer.pkg" ]; then
            mv TremoloViola-Installer.pkg artifacts/
            echo "✅ Installer added to artifacts"
            
            # Update build report
            echo "" >> artifacts/build-report.txt
            echo "=== INSTALLER INFORMATION ===" >> artifacts/build-report.txt
            echo "Installer package: TremoloViola-Installer.pkg" >> artifacts/build-report.txt
            echo "Package size: $(ls -lh artifacts/TremoloViola-Installer.pkg | awk '{print $5}')" >> artifacts/build-report.txt
            echo "Created: $(date)" >> artifacts/build-report.txt
            echo "" >> artifacts/build-report.txt
            echo "INSTALLATION INSTRUCTIONS:" >> artifacts/build-report.txt
            echo "1. Download TremoloViola-Installer.pkg" >> artifacts/build-report.txt
            echo "2. Double-click to run the installer" >> artifacts/build-report.txt
            echo "3. Follow the installation prompts" >> artifacts/build-report.txt
            echo "4. Restart your DAW to see the new plugin" >> artifacts/build-report.txt
            
          else
            echo "❌ Installer package not found"
            echo "Installer creation failed - see previous steps" >> artifacts/build-report.txt
          fi
          
          # Clean up staging directory
          rm -rf installer_staging
          
          echo "Final artifacts:"
          ls -la artifacts/

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: TremoloViola-macOS-Builds
          path: artifacts/
          retention-days: 30
          if-no-files-found: warn

  build-windows:
    name: Build Windows Plugin
    runs-on: windows-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          
      - name: Update submodules (pull juce)
        run: |
          git submodule update --init --recursive
          
      - name: Setup Environment
        run: |
          echo "Setting up environment variables"
          echo "JUCE_VERSION=8.0.6" >> $env:GITHUB_ENV
          echo "PLUGIN_NAME=TremoloViolaVST" >> $env:GITHUB_ENV
      
      - name: Print directory
        run: |
          Get-Location
          Get-ChildItem
          
      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v1
          
      - name: Build Projucer
        run: |
          cd QuackerVST/JUCE/extras/Projucer/Builds/VisualStudio2022
          msbuild Projucer.sln /p:Configuration=Release /p:Platform=x64
          
          # Verify Projucer build
          if (-not (Test-Path "x64/Release/App/Projucer.exe")) {
            Write-Error "Projucer build failed! Executable not found."
            exit 1
          }
          
          # Create a reference to the Projucer in the repository root
          cd $env:GITHUB_WORKSPACE
          $projucerPath = "QuackerVST\JUCE\extras\Projucer\Builds\VisualStudio2022\x64\Release\App\Projucer.exe"
          echo "PROJUCER_PATH=$projucerPath" >> $env:GITHUB_ENV
      
      - name: Verify Projucer
        run: |
          & "$env:PROJUCER_PATH" --version
          
      - name: Resave JUCER file
        run: |
          echo "Resaving project file"
          & "$env:PROJUCER_PATH" --resave "QuackerVST\QuackerVST.jucer"
       
      - name: Verify Visual Studio project
        run: |
          echo "Checking if Visual Studio project exists"
          Get-ChildItem -Path "QuackerVST\Builds\VisualStudio2022" -Recurse
          
      - name: Build Plugin
        run: |
          echo "Building plugin with verbose output"
          cd "QuackerVST\Builds\VisualStudio2022"
          msbuild "TremoloViolaVST.sln" /p:Configuration=Release /p:Platform=x64 /v:detailed
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Build failed with exit code $LASTEXITCODE"
            exit 1
          }
          echo "Build completed successfully"
      
      - name: Examine build outputs
        run: |
          echo "Examining build directories for outputs"
          Get-ChildItem -Path "QuackerVST\Builds\VisualStudio2022" -Recurse | Where-Object { $_.PSIsContainer } | ForEach-Object { $_.FullName }
          
          echo "Looking for VST3 files:"
          Get-ChildItem -Path "QuackerVST\Builds" -Recurse -Include "*.vst3" | ForEach-Object { $_.FullName }
          
          echo "Looking for executable files:"
          Get-ChildItem -Path "QuackerVST\Builds" -Recurse -Include "*.exe" | ForEach-Object { $_.FullName }
          
      - name: Create artifacts directory
        run: |
          echo "Creating artifacts directory"
          mkdir artifacts
      
      - name: Package Plugin with comprehensive search
        run: |
          echo "Searching for plugin files throughout the project"
          
          # Comprehensive search for VST3 plugins (looking for both directories and files)
          $vst3Files = Get-ChildItem -Path "QuackerVST\Builds" -Recurse -Include "*.vst3*"
          if ($vst3Files) {
            foreach ($vst3File in $vst3Files) {
              $fileName = Split-Path $vst3File -Leaf
              $baseName = $fileName -replace "\.vst3.*$", ""
              echo "Found VST3: $vst3File, packaging as $baseName"
              
              # Check if it's a directory or file and package appropriately
              if (Test-Path -Path $vst3File -PathType Container) {
                Compress-Archive -Path "$vst3File\*" -DestinationPath "artifacts\$baseName-VST3-Windows.zip" -Force
              } else {
                Compress-Archive -Path $vst3File -DestinationPath "artifacts\$baseName-VST3-Windows.zip" -Force
              }
            }
          } else {
            echo "No VST3 files found."
          }
          
          # Comprehensive search for standalone executables
          $exeFiles = Get-ChildItem -Path "QuackerVST\Builds" -Recurse -Include "TremoloViola*.exe", "TremoloViolaVST*.exe"
          if ($exeFiles) {
            foreach ($exeFile in $exeFiles) {
              $fileName = Split-Path $exeFile -Leaf
              $baseName = $fileName -replace "\.exe$", ""
              echo "Found Standalone: $exeFile, packaging as $baseName"
              Compress-Archive -Path $exeFile -DestinationPath "artifacts\$baseName-Standalone-Windows.zip" -Force
            }
          } else {
            echo "No standalone executables found."
          }
          
          # If no files were found, create a dummy file to prevent upload failure
          if (-not (Get-ChildItem -Path artifacts\*.zip)) {
            echo "No plugin files found. Creating a dummy file."
            "No plugin files were found during the build process. Please check the build logs." | Out-File -FilePath "artifacts\build-log.txt"
            
            # Create a log dump to help diagnose the issue
            echo "Creating build diagnostic information..."
            echo "========== DIRECTORY STRUCTURE ==========" > artifacts\build-diagnostics.txt
            Get-ChildItem -Path "QuackerVST\Builds" -Recurse | Out-File -Append -FilePath artifacts\build-diagnostics.txt
          }
          
          # List what's in the artifacts directory
          echo "Contents of artifacts directory:"
          Get-ChildItem artifacts\
      
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: TremoloViola-Windows-Builds
          path: artifacts/
          retention-days: 30
          if-no-files-found: warn